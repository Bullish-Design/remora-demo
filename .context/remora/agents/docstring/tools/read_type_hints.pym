from grail import Input

source_code: str = Input("source_code")
file_path: str = Input("file_path")


def _find_signature_line(source: str) -> str | None:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("async def ") or stripped.startswith("def "):
            return stripped
    return None


def _parse_parameters(raw: str) -> list[dict[str, str]]:
    params: list[dict[str, str]] = []
    pieces = [piece.strip() for piece in raw.split(",") if piece.strip()]
    for piece in pieces:
        name_type = piece.split("=", 1)[0].strip()
        if ":" not in name_type:
            continue
        name, annotation = [part.strip() for part in name_type.split(":", 1)]
        if annotation:
            params.append({"name": name, "annotation": annotation})
    return params


def _parse_return_type(line: str) -> str | None:
    if ")" not in line or "->" not in line:
        return None
    after = line.split(")", 1)[1]
    if "->" not in after:
        return None
    return after.split("->", 1)[1].split(":", 1)[0].strip() or None


try:
    if not source_code:
        raise ValueError("Source code is required.")
    
    signature_line = _find_signature_line(source_code)
    if not signature_line:
        error_message = "No function definition found in node text."
        result = {
            "result": None,
            "summary": f"Error: {error_message}",
            "knowledge_delta": {},
            "outcome": "error",
            "error": error_message,
        }
    else:
        params_part = signature_line.split("(", 1)[1].split(")", 1)[0]
        parameters = _parse_parameters(params_part)
        return_annotation = _parse_return_type(signature_line)
        has_annotations = bool(parameters or return_annotation)
        raw_result = {
            "parameters": parameters,
            "return_annotation": return_annotation,
            "has_annotations": has_annotations,
        }
        if has_annotations:
            summary = f"Found type hints for {len(parameters)} parameter(s)"
            outcome = "success"
        else:
            summary = "No type hints found"
            outcome = "partial"
        result = {
            "result": raw_result,
            "summary": summary,
            "knowledge_delta": {
                "type_hints_present": has_annotations,
                "type_hints_count": len(parameters),
                "type_hints_return": return_annotation,
            },
            "outcome": outcome,
        }
except Exception as exc:
    result = {
        "result": None,
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
