from grail import Input, external

source_code: str = Input("source_code")
file_path: str = Input("file_path")
docstring: str = Input("docstring")
style: str = Input("style", default="google")

@external
async def write_file(path: str, content: str) -> bool:
    ...


def _find_function_name(source: str) -> str | None:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("def "):
            return stripped[len("def ") :].split("(", 1)[0].strip()
        if stripped.startswith("async def "):
            return stripped[len("async def ") :].split("(", 1)[0].strip()
    return None


def _format_docstring(text: str, indent: str) -> list[str]:
    lines = text.splitlines()
    if not lines:
        return [f'{indent}""" """']
    if len(lines) == 1:
        return [f'{indent}""" {lines[0]} """']
    formatted = [f'{indent}"""']
    formatted.extend(f"{indent}{line}" for line in lines)
    formatted.append(f'{indent}"""')
    return formatted


def _find_function_line(lines: list[str], name: str) -> tuple[int, int] | None:
    for index, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith(f"def {name}") or stripped.startswith(f"async def {name}"):
            return index, len(line) - len(line.lstrip())
    return None


def _find_docstring_block(lines: list[str], start_index: int, base_indent: int) -> tuple[int, int] | None:
    for index in range(start_index + 1, len(lines)):
        line = lines[index]
        stripped = line.strip()
        if not stripped:
            continue
        indent = len(line) - len(line.lstrip())
        if indent <= base_indent:
            return None
        if stripped.startswith('"""') or stripped.startswith("'''"):
            quote = stripped[:3]
            if stripped.endswith(quote) and len(stripped) > 3:
                return index, index
            for end_index in range(index + 1, len(lines)):
                if quote in lines[end_index]:
                    return index, end_index
            return index, index
        return None
    return None


try:
    _ = style
    if not source_code:
        raise ValueError("Source code is required.")
    if not docstring:
        raise ValueError("Docstring text is required.")

    trailing_newline = source_code.endswith("\n")
    lines = source_code.splitlines()

    function_name = _find_function_name(source_code)
    if not function_name:
        raise ValueError("Function definition not found in source code.")

    location = _find_function_line(lines, function_name)
    if not location:
        raise ValueError("Function definition not found in source code.")

    def_line_index, base_indent = location
    indent = " " * (base_indent + 4)

    docstring_lines = _format_docstring(docstring, indent)
    block = _find_docstring_block(lines, def_line_index, base_indent)

    replaced_existing = False
    if block:
        start, end = block
        lines = lines[:start] + docstring_lines + lines[end + 1 :]
        replaced_existing = True
    else:
        insert_at = def_line_index + 1
        lines = lines[:insert_at] + docstring_lines + lines[insert_at:]

    updated_content = "\n".join(lines)
    if trailing_newline:
        updated_content += "\n"

    await write_file(file_path, updated_content)

    raw_result = {
        "success": True,
        "replaced_existing": replaced_existing,
        "target_file": file_path,
    }
    summary = "Replaced existing docstring" if replaced_existing else "Inserted new docstring"
    result = {
        "result": raw_result,
        "summary": summary,
        "knowledge_delta": {
            "docstring_updated": True,
            "docstring_replaced": replaced_existing,
            "docstring_target_file": file_path,
        },
        "outcome": "success",
        "written_file": file_path,
        "content": updated_content,
    }
except Exception as exc:
    result = {
        "result": {"success": False, "error": str(exc)},
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
