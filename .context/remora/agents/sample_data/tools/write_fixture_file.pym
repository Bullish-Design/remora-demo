from typing import Any

from grail import Input, external

fixtures: list[object] = Input("fixtures")
format: str = Input("format", default="json")
source_code: str = Input("source_code", default="")

@external
async def write_file(path: str, content: str) -> bool:
    ...


def _json_escape(text: str) -> str:
    return (
        text.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")
    )


def _to_json(value: Any) -> str:
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int) or isinstance(value, float):
        return str(value)
    if isinstance(value, str):
        return f'"{_json_escape(value)}"'
    if isinstance(value, list):
        inner = ", ".join(_to_json(item) for item in value)
        return f"[{inner}]"
    if isinstance(value, dict):
        pieces = []
        for key in value:
            pieces.append(f"{_to_json(str(key))}: {_to_json(value[key])}")
        return "{" + ", ".join(pieces) + "}"
    return _to_json(str(value))


def _yaml_escape(value: str) -> str:
    if value == "" or any(ch in value for ch in [":", "#", "\n", "\r", "\t"]):
        escaped = value.replace('"', '\\"')
        return f'"{escaped}"'
    return value


def _yaml_scalar(value: Any) -> str:
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int) or isinstance(value, float):
        return str(value)
    return _yaml_escape(str(value))


def _to_yaml(values: list[object]) -> str:
    lines: list[str] = []
    for item in values:
        if isinstance(item, dict):
            if not item:
                lines.append("- {}")
                continue
            first = True
            for key in item:
                prefix = "- " if first else "  "
                lines.append(f"{prefix}{key}: {_yaml_scalar(item[key])}")
                first = False
        else:
            lines.append(f"- {_yaml_scalar(item)}")
    return "\n".join(lines)


def _find_function_name(source: str) -> str:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("def "):
            return stripped[len("def ") :].split("(", 1)[0].strip()
        if stripped.startswith("async def "):
            return stripped[len("async def ") :].split("(", 1)[0].strip()
    return "fixture"


try:
    if not isinstance(fixtures, list) or not fixtures:
        raise ValueError("Fixtures must be a non-empty list.")

    fmt = str(format or "json").lower()
    if fmt in {"yaml", "yml"}:
        content = _to_yaml(fixtures)
        extension = "yaml"
    elif fmt == "json":
        content = _to_json(fixtures)
        extension = "json"
    else:
        raise ValueError(f"Unsupported fixture format: {fmt}")

    function_name = _find_function_name(source_code) if source_code else "fixture"
    target_path = f"fixtures/{function_name}_fixtures.{extension}"

    await write_file(target_path, content)

    raw_result = {"success": True, "path": target_path, "format": extension}
    result = {
        "result": raw_result,
        "summary": f"Wrote fixture file {target_path}",
        "knowledge_delta": {
            "fixture_path": target_path,
            "fixture_format": extension,
            "fixtures_count": len(fixtures),
        },
        "outcome": "success",
        "written_file": target_path,
        "content": content,
    }
except Exception as exc:
    result = {
        "result": {"success": False, "error": str(exc)},
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
