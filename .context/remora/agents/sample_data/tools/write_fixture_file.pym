from grail import Input, external
from typing import Any

fixtures: list[object] = Input("fixtures")
format_input: str = Input("format", default="json")
node_text_input: str | None = Input("node_text", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def write_file(path: str, content: str) -> bool:
    """Write text content to a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


def _json_escape(text: str) -> str:
    return (
        text.replace("\\", "\\\\")
        .replace('"', "\\\"")
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")
    )


def _to_json(value: Any) -> str:
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int) or isinstance(value, float):
        return str(value)
    if isinstance(value, str):
        return f"\"{_json_escape(value)}\""
    if isinstance(value, list):
        inner = ", ".join(_to_json(item) for item in value)
        return f"[{inner}]"
    if isinstance(value, dict):
        pieces = []
        for key in value:
            pieces.append(f"{_to_json(str(key))}: {_to_json(value[key])}")
        return "{" + ", ".join(pieces) + "}"
    return _to_json(str(value))


def _yaml_escape(value: str) -> str:
    if value == "" or any(ch in value for ch in [":", "#", "\n", "\r", "\t"]):
        return f"\"{value.replace('"', '\\"')}\""
    return value


def _yaml_scalar(value: Any) -> str:
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int) or isinstance(value, float):
        return str(value)
    return _yaml_escape(str(value))


def _to_yaml(values: list[object]) -> str:
    lines: list[str] = []
    for item in values:
        if isinstance(item, dict):
            if not item:
                lines.append("- {}")
                continue
            first = True
            for key in item:
                prefix = "- " if first else "  "
                lines.append(f"{prefix}{key}: {_yaml_scalar(item[key])}")
                first = False
        else:
            lines.append(f"- {_yaml_scalar(item)}")
    return "\n".join(lines)


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


def _find_function_name(source: str) -> str:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("def "):
            return stripped[len("def ") :].split("(", 1)[0].strip()
        if stripped.startswith("async def "):
            return stripped[len("async def ") :].split("(", 1)[0].strip()
    return "fixture"


async def _load_node_text() -> str:
    if node_text_input:
        return node_text_input
    stored = await _read_optional(path=".remora/node_text")
    if stored:
        return stored
    return ""


try:
    if not isinstance(fixtures, list) or not fixtures:
        raise ValueError("Fixtures must be a non-empty list.")

    fmt = str(format_input or "json").lower()
    if fmt in {"yaml", "yml"}:
        content = _to_yaml(fixtures)
        extension = "yaml"
    elif fmt == "json":
        content = _to_json(fixtures)
        extension = "json"
    else:
        raise ValueError(f"Unsupported fixture format: {fmt}")

    node_text = await _load_node_text()
    function_name = _find_function_name(node_text) if node_text else "fixture"
    target_path = f"fixtures/{function_name}_fixtures.{extension}"

    await write_file(path=target_path, content=content)
    raw_result = {"success": True, "path": target_path, "format": extension}
    result = {
        "result": raw_result,
        "summary": f"Wrote fixture file {target_path}",
        "knowledge_delta": {
            "fixture_path": target_path,
            "fixture_format": extension,
            "fixtures_count": len(fixtures),
        },
        "outcome": "success",
    }
except Exception as exc:
    result = {
        "result": {"success": False, "error": str(exc)},
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
