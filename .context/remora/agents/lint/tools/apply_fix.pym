from __future__ import annotations

from typing import Any

from grail import Input, external

source_code: str = Input("source_code")
file_path: str = Input("file_path")
issue_code: str = Input("issue_code")
line_number: int = Input("line_number")
fixed_content: str | None = Input("fixed_content", default=None)
exit_code: int = Input("exit_code", default=0)
stderr: str = Input("stderr", default="")


@external
async def write_file(path: str, content: str) -> bool:
    ...


def _build_partial_result(message: str) -> dict[str, Any]:
    return {
        "result": {"success": False, "message": message},
        "summary": message,
        "knowledge_delta": {
            "fix_applied": False,
            "last_fix_issue_code": issue_code,
            "last_fix_line": line_number,
        },
        "outcome": "partial",
    }


try:
    if not source_code:
        raise ValueError("Source code is required.")
    if not issue_code or line_number <= 0:
        raise ValueError("issue_code and line_number are required.")

    candidate_content = fixed_content if fixed_content is not None else source_code
    if exit_code not in {0, 1}:
        error_message = stderr.strip() or f"ruff exit code {exit_code}"
        result = {
            "result": {"success": False, "message": error_message},
            "summary": f"Error: {error_message}",
            "knowledge_delta": {
                "fix_applied": False,
                "last_fix_issue_code": issue_code,
                "last_fix_line": line_number,
            },
            "outcome": "error",
            "error": error_message,
        }
    else:
        content_changed = candidate_content != source_code
        if content_changed:
            await write_file(file_path, candidate_content)
            message = f"Applied fix for {issue_code} at line {line_number}"
            result = {
                "result": {
                    "success": True,
                    "message": message,
                    "fixed_code": candidate_content,
                },
                "summary": message,
                "knowledge_delta": {
                    "fix_applied": True,
                    "last_fix_issue_code": issue_code,
                    "last_fix_line": line_number,
                },
                "outcome": "success",
                "written_file": file_path,
                "content": candidate_content,
            }
        else:
            result = _build_partial_result(
                f"No fixable issue for {issue_code} at line {line_number}"
            )
except Exception as exc:
    result = {
        "result": {"success": False, "message": str(exc)},
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
