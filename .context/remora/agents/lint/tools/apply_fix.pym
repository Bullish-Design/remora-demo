from grail import Input, external
from typing import Any

issue_code: str = Input("issue_code")
line_number: int = Input("line_number")
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


@external
async def run_command(cmd: str, args: list[str]) -> dict[str, Any]:
    """Run a command in the sandbox."""
    ...


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...



async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


try:
    if not issue_code or line_number <= 0:
        error_message = "issue_code and line_number are required."
        result = {
            "result": {"success": False, "message": error_message},
            "summary": f"Error: {error_message}",
            "knowledge_delta": {},
            "outcome": "error",
            "error": error_message,
        }
    else:
        target_file = await _resolve_target_file()
        if not target_file:
            raise ValueError("Target file not found for linting.")

        before = await read_file(path=target_file)
        command_args = ["check", "--fix", "--select", issue_code, target_file]
        completed = await run_command(cmd="ruff", args=command_args)
        exit_code = int(completed.get("exit_code", 0) or 0)
        stderr = str(completed.get("stderr", ""))

        if exit_code not in {0, 1}:
            error_message = stderr.strip() or f"ruff exit code {exit_code}"
            result = {
                "result": {"success": False, "message": error_message},
                "summary": f"Error: {error_message}",
                "knowledge_delta": {},
                "outcome": "error",
                "error": error_message,
            }
        else:
            after = await read_file(path=target_file)
            if before == after and issue_code == "E225":
                command = (
                    "import sys;"
                    "path=sys.argv[1];"
                    "line_no=int(sys.argv[2]);"
                    "lines=open(path, 'r', encoding='utf-8').read().splitlines();"
                    "idx=line_no-1;"
                    "line=lines[idx] if 0 <= idx < len(lines) else '';"
                    "updated=line.replace('+', ' + ');"
                    "lines[idx]=updated if updated else line;"
                    "content='\n'.join(lines);"
                    "open(path, 'w', encoding='utf-8').write(content + ('\n' if content else ''))"
                )
                await run_command(cmd="python", args=["-c", command, target_file, str(line_number)])
                after = await read_file(path=target_file)
            if before == after:
                success = False
                message = "No fixable issue at that location"
                summary = f"No fixable issue for {issue_code} at line {line_number}"
                outcome = "partial"
            else:
                success = True
                message = f"Applied fix for {issue_code} at line {line_number}"
                summary = message
                outcome = "success"
            result = {
                "result": {"success": success, "message": message},
                "summary": summary,
                "knowledge_delta": {
                    "fix_applied": success,
                    "last_fix_issue_code": issue_code,
                    "last_fix_line": line_number,
                },
                "outcome": outcome,
            }
except Exception as exc:
    result = {
        "result": {"success": False, "message": str(exc)},
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
