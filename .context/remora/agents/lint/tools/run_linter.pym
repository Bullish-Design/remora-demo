from grail import Input, external
from typing import Any

check_only: bool = Input("check_only", default=True)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


@external
async def run_command(cmd: str, args: list[str]) -> dict[str, Any]:
    """Run a command in the sandbox."""
    ...


@external
async def run_json_command(cmd: str, args: list[str]) -> Any:
    """Run a command and parse its stdout as JSON."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None

try:
    target_file = await _resolve_target_file()
    if not target_file:
        raise ValueError("Target file not found for linting.")

    command_args = ["check", "--output-format", "json", "--select", "E,W,F"]
    if not check_only:
        command_args.append("--fix")
    command_args.append(target_file)

    issues_raw = await run_json_command(cmd="ruff", args=command_args)

    if isinstance(issues_raw, dict) and "error" in issues_raw:
        error_message = issues_raw.get("stderr", "").strip() or f"ruff exit code {issues_raw.get('exit_code')}"
        result = {
            "result": None,
            "summary": f"Error: {error_message}",
            "knowledge_delta": {},
            "outcome": "error",
            "error": error_message,
        }
    else:
        issues = []
        if issues_raw:
            for issue_data in issues_raw:
                code_val = issue_data.get("code")
                if isinstance(code_val, dict):
                    code_str = str(code_val.get("value", ""))
                else:
                    code_str = str(code_val or "")
                
                fix_data = issue_data.get("fix")
                fixable = fix_data is not None
                if isinstance(fix_data, dict) and fix_data.get("applicability") == "unfixable":
                    fixable = False
                    
                issues.append({
                    "code": code_str,
                    "line": issue_data.get("location", {}).get("row", 0),
                    "col": issue_data.get("location", {}).get("column", 0),
                    "message": str(issue_data.get("message", "")),
                    "fixable": fixable
                })
                
        fixable_count = sum(1 for issue in issues if issue.get("fixable"))
        total = len(issues)
        raw_result = {"issues": issues, "total": total, "fixable_count": fixable_count}
        if total == 0:
            summary = "No lint errors found"
            outcome = "success"
        elif fixable_count > 0:
            summary = f"Found {total} lint errors, {fixable_count} fixable"
            outcome = "partial"
        else:
            summary = f"Found {total} lint errors"
            outcome = "partial"
        result = {
            "result": raw_result,
            "summary": summary,
            "knowledge_delta": {
                "lint_errors_remaining": total,
                "lint_errors_fixable": fixable_count,
            },
            "outcome": outcome,
        }
except Exception as exc:
    result = {
        "result": None,
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
