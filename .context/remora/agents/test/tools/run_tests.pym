from grail import Input
from typing import Any

test_file: str = Input("test_file")
target_file: str = Input("target_file")
xml_report: str = Input("xml_report", default="")
stdout: str = Input("stdout", default="")
stderr: str = Input("stderr", default="")
exit_code: int = Input("exit_code", default=0)
structured_report: dict[str, Any] | None = Input("structured_report", default=None)


def _read_attr(tag: str, key: str) -> int:
    marker = f'{key}="'
    if marker not in tag:
        return 0
    value = tag.split(marker, 1)[1].split('"', 1)[0]
    try:
        return int(value)
    except Exception:
        return 0


def _parse_totals(xml: str) -> dict[str, int]:
    tests_total = 0
    failures_total = 0
    errors_total = 0
    skipped_total = 0
    index = 0
    while True:
        start = xml.find("<testsuite", index)
        if start == -1:
            break
        end = xml.find(">", start)
        if end == -1:
            break
        tag = xml[start:end]
        tests_total += _read_attr(tag, "tests")
        failures_total += _read_attr(tag, "failures")
        errors_total += _read_attr(tag, "errors")
        skipped_total += _read_attr(tag, "skipped")
        index = end + 1
    return {
        "tests": tests_total,
        "failures": failures_total,
        "errors": errors_total,
        "skipped": skipped_total,
    }


def _read_str_attr(tag: str, key: str) -> str:
    marker = f'{key}="'
    if marker not in tag:
        return ""
    return tag.split(marker, 1)[1].split('"', 1)[0]


def _extract_failure_detail(block: str, tag: str) -> str:
    start = block.find(f"<{tag}")
    if start == -1:
        return ""
    end_tag = block.find(">", start)
    if end_tag == -1:
        return ""
    header = block[start:end_tag]
    message = _read_str_attr(header, "message")
    if message:
        return message.strip()
    close = block.find(f"</{tag}>", end_tag)
    if close == -1:
        return ""
    return block[end_tag + 1 : close].strip()


def _parse_failures(xml: str) -> list[dict[str, str]]:
    failures: list[dict[str, str]] = []
    index = 0
    while True:
        start = xml.find("<testcase", index)
        if start == -1:
            break
        end = xml.find(">", start)
        if end == -1:
            break
        tag = xml[start:end]
        name = _read_str_attr(tag, "name")
        classname = _read_str_attr(tag, "classname")
        full_name = f"{classname}::{name}" if classname else name
        close = xml.find("</testcase>", end)
        if close == -1:
            index = end + 1
            continue
        body = xml[end:close]
        detail = ""
        if "<failure" in body:
            detail = _extract_failure_detail(body, "failure")
        elif "<error" in body:
            detail = _extract_failure_detail(body, "error")
        if detail:
            failures.append({"test": full_name, "message": detail})
        index = close + len("</testcase>")
    return failures


try:
    if not test_file:
        raise ValueError("Test file path is required.")

    if not structured_report and not xml_report.strip():
        raise ValueError("Test report data is required.")

    if structured_report:
        totals = {
            "tests": int(structured_report.get("tests", 0)),
            "failures": int(structured_report.get("failures", 0)),
            "errors": int(structured_report.get("errors", 0)),
            "skipped": int(structured_report.get("skipped", 0)),
        }
        failures = [
            dict(item)
            for item in structured_report.get("failures", [])
            if isinstance(item, dict)
        ]
    else:
        totals = _parse_totals(xml_report)
        failures = _parse_failures(xml_report)

    passed = totals["tests"] - totals["failures"] - totals["errors"] - totals["skipped"]
    passed_count = max(passed, 0)
    failed_count = totals["failures"]
    error_count = totals["errors"]
    raw_result = {
        "passed": passed_count,
        "failed": failed_count,
        "errors": error_count,
        "failures": failures,
    }

    if exit_code not in {0, 1}:
        error_count = max(error_count, 1)
        raw_result["errors"] = error_count
        raw_result["failures"].append(
            {
                "test": "pytest",
                "message": stderr.strip() or stdout.strip() or "Pytest failed to run.",
            }
        )

    total_tests = raw_result["passed"] + raw_result["failed"] + raw_result["errors"]
    failed_total = raw_result["failed"] + raw_result["errors"]
    if failed_total == 0:
        summary = f"All {total_tests} tests passed"
        outcome = "success"
    else:
        summary = f"{failed_total} of {total_tests} tests failed"
        outcome = "partial"

    result = {
        "result": raw_result,
        "summary": summary,
        "knowledge_delta": {
            "tests_passed": raw_result["passed"],
            "tests_failed": raw_result["failed"],
            "tests_errors": raw_result["errors"],
            "test_file": test_file,
            "target_file": target_file,
        },
        "outcome": outcome,
    }
except Exception as exc:
    result = {
        "result": {
            "passed": 0,
            "failed": 0,
            "errors": 1,
            "failures": [],
        },
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
