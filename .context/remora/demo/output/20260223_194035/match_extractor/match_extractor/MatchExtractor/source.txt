class MatchExtractor:
    """Executes compiled queries against parsed trees and builds CSTNode lists.

    This extractor is completely language-agnostic. It relies on the .scm query
    files to define:
    - What nodes to capture via @X.def
    - What names to extract via @X.name
    - What types nodes should have (derived from capture prefix X)

    Usage:
        extractor = MatchExtractor()
        nodes = extractor.extract(
            file_path=Path("example.py"),
            tree=tree,
            source_bytes=source_bytes,
            queries=[compiled_query_1, compiled_query_2],
        )
    """

    def extract(
        self,
        file_path: Path,
        tree: Tree,
        source_bytes: bytes,
        queries: list[CompiledQuery],
    ) -> list[CSTNode]:
        """Run all queries against a tree and return discovered CSTNodes.

        Args:
            file_path: Path to the source file (for node_id and file_path fields).
            tree: Parsed tree-sitter tree.
            source_bytes: Raw source bytes (for text extraction).
            queries: List of compiled queries to execute.

        Returns:
            Deduplicated, sorted list of CSTNode instances.
        """
        nodes: list[CSTNode] = []
        seen_ids: set[str] = set()

        for compiled_query in queries:
            new_nodes = self._run_query(file_path, tree, source_bytes, compiled_query)
            for node in new_nodes:
                if node.node_id not in seen_ids:
                    seen_ids.add(node.node_id)
                    nodes.append(node)

        nodes.sort(key=lambda n: (str(n.file_path), n.start_byte, n.node_type, n.name))
        return nodes

    def _run_query(
        self,
        file_path: Path,
        tree: Tree,
        source_bytes: bytes,
        compiled_query: CompiledQuery,
    ) -> list[CSTNode]:
        """Run a single query and extract CSTNodes from matches.

        The query file name determines the node type. For example:
        - function.scm → expects @function.def and @function.name captures
        - class.scm → expects @class.def and @class.name captures
        - file.scm → expects @file.def capture (name derived from file stem)

        For queries with multiple node types (e.g., function.scm with both
        @function.def and @method.def), each capture prefix defines its type.
        """
        cursor = QueryCursor(compiled_query.query)
        nodes: list[CSTNode] = []

        # Process matches (each match groups related captures)
        for match in cursor.matches(tree.root_node):
            # Group captures by their prefix (e.g., "function", "method", "class")
            # match[1] is a dict mapping capture_name -> list of Node objects
            captures_by_prefix: dict[str, dict[str, list[Node]]] = {}

            for capture_name, ts_nodes in match[1].items():
                parts = capture_name.split(".")
                if len(parts) != 2:
                    continue

                prefix, suffix = parts
                if prefix not in captures_by_prefix:
                    captures_by_prefix[prefix] = {}
                if suffix not in captures_by_prefix[prefix]:
                    captures_by_prefix[prefix][suffix] = []
                captures_by_prefix[prefix][suffix].extend(ts_nodes)

            # Build nodes for each captured prefix that has a .def
            for prefix, captures in captures_by_prefix.items():
                def_nodes = captures.get("def", [])
                name_nodes = captures.get("name", [])

                for i, def_node in enumerate(def_nodes):
                    node_type = prefix  # e.g., "function", "method", "class", "table"

                    # Extract name from @X.name capture, or use file stem for file nodes
                    if i < len(name_nodes):
                        name_node = name_nodes[i]
                        name = source_bytes[name_node.start_byte : name_node.end_byte].decode("utf-8", errors="replace")
                    elif node_type == "file":
                        name = file_path.stem
                    else:
                        name = "unknown"

                    text = source_bytes[def_node.start_byte : def_node.end_byte].decode("utf-8", errors="replace")

                    node_id = compute_node_id(file_path, node_type, name)

                    nodes.append(
                        CSTNode(
                            node_id=node_id,
                            node_type=node_type,
                            name=name,
                            file_path=file_path,
                            start_byte=def_node.start_byte,
                            end_byte=def_node.end_byte,
                            text=text,
                            start_line=def_node.start_point.row + 1,
                            end_line=def_node.end_point.row + 1,
                        )
                    )

        return nodes