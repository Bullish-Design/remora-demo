1.  **Ingestion:** User requests: *"Update all configuration to a Pydantic Settings baseclass."*
2.  **Root Decomposition:** The `TaskManager` creates a `DECOMPOSITION` Root `TaskNode`. It provisions `Workspace A` and assigns the `"architect"` bundle.
3.  **Iterative Breakdown (Inside Workspace A):** The Architect analyzes the prompt and realizes it lacks context. It spawns three parallel `RESEARCH` sub-tasks using `spawn_sub_task.pym`:
    *   **Research Task 1:** "Find current config usage in library." (Spawns an agent that uses Tree-sitter tools to map config imports).
    *   **Research Task 2:** "Research pydantic-settings." (Spawns an agent that searches `COMPREHENSIVE_EMBEDDINGS_MODEL_SUITE.md` or external docs for best practices).
    *   **Research Task 3:** "Determine validation targets." (Spawns an agent that analyzes `tests/` to see how config is currently tested).
4.  **Context Aggregation:** As the Research tasks complete, they write their findings back to the Hub (e.g., `KV.set("golden_example", "...")`). The Architect in `Workspace A` observes these Hub events.
5.  **Execution Tree Generation:** Armed with context and a clear "Definition of Done" (e.g., "pytest suite passes"), the Architect spawns the actual `EXECUTION` sub-tasks (e.g., "Refactor `config.py`", "Update `cli.py` to use new config").
6.  **Verification Recursion:** Once an `EXECUTION` task finishes, the Architect spawns a `VERIFICATION` sub-task. If verification fails (pytest errors), the Verification node spawns a `DEBUG` node (Temporal Recursion) with the stack trace, which may then spawn further `EXECUTION` nodes to fix the issue.
7.  **Upward Resolution:** Once the Verification node confirms the "Definition of Done" is met, the Root `TaskNode` resolves. The `WorkspaceBridge` recursively merges the execution sandboxes back to the trunk.